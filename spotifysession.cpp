#include <cassert>
#include <iostream>
#include <sstream>
#include <stdexcept>
#include <string>
#include <QCoreApplication>
#include <spotify/api.h>
#include "spotifysession.hpp"
#include "appkey.h"

namespace {

std::string utf8_str(QString s) {
	QByteArray a = s.toUtf8();
	return std::string(a.data(), a.data() + a.size());
}

struct my_sp_userdata {
	SpotifyCallbacks* spotifyCallbacks;
	SpotifySession* spotifySession;
	QEvent::Type spotifyEvent;
};

my_sp_userdata* userdata(sp_session* session) {
	return reinterpret_cast<my_sp_userdata*>(sp_session_userdata(session));
}

// These events happen on a different thread than main_thread:
void handle_notify_main_thread(sp_session* session) {
	my_sp_userdata* ud = userdata(session);

	std::cout << "notify_main_thread" << std::endl;
	QCoreApplication::postEvent(
		ud->spotifySession,
		new QEvent(ud->spotifyEvent)
	);
}

// These events happen on the main thread:
void handle_logged_in(sp_session* session, sp_error error) {
	if (error != SP_ERROR_OK) {
		std::ostringstream ss;
		ss << "failed to log in to spotify: " << sp_error_message(error);
		throw std::runtime_error(ss.str());
	}

	userdata(session)->spotifyCallbacks->sp_loggedIn();
}

void handle_logged_out(sp_session* session) {
	userdata(session)->spotifyCallbacks->sp_loggedOut();
}

void handle_metadata_updated(sp_session* session) {
	userdata(session)->spotifyCallbacks->sp_metadataUpdated();
}

void handle_play_token_lost(sp_session* session) {
	userdata(session)->spotifyCallbacks->sp_playTokenLost();
}

void handle_connection_error(sp_session* session, sp_error) {
	userdata(session)->spotifyCallbacks->sp_connectionError();
}

void handle_message_to_user(sp_session* session, const char* msg) {
	userdata(session)->spotifyCallbacks->sp_messageToUser(QString::fromUtf8(msg));
}

void handle_log_message(sp_session* session, const char* msg) {
	userdata(session)->spotifyCallbacks->sp_logMessage(QString::fromUtf8(msg));
}

}

SpotifySession::SpotifySession(QObject* parent, QString username_, QString password_) :
	QObject(parent),
	username(username_),
	password(password_)
{
	spotifyNotifyMainThreadEvent = static_cast<QEvent::Type>(QEvent::registerEventType());
}

SpotifySession::~SpotifySession() {
	// Would delete the sp_session-object, but it is not allowed by the API
}

bool SpotifySession::event(QEvent* e) {
	if (e->type() == spotifyNotifyMainThreadEvent) {
		int timeout = -1;
		sp_session_process_events(session, &timeout);
		std::cout << "Timeout: " << timeout << std::endl;
		return true;
	}

	return QObject::event(e);
}

void SpotifySession::connect() {
	sp_error error;

	sp_session_config config;

	// Always do this. It allows libspotify to check for
	// header/library inconsistencies.
	config.api_version = SPOTIFY_API_VERSION;

	// The path of the directory to store the cache. This must be specified.
	// Please read the documentation on preferred values.
	config.cache_location = "tmp";

	// The path of the directory to store the settings. This must be specified.
	// Please read the documentation on preferred values.
	config.settings_location = "tmp";

	// The key of the application. They are generated by Spotify,
	// and are specific to each application using libspotify.
	config.application_key = g_appkey;
	config.application_key_size = g_appkey_size;

	// This identifies the application using some
	// free-text string [1, 255] characters.
	std::string appname = utf8_str(QCoreApplication::applicationName());
	config.user_agent = appname.c_str();

	my_sp_userdata ud;
	ud.spotifyCallbacks = this;
	ud.spotifySession = this;
	ud.spotifyEvent = spotifyNotifyMainThreadEvent;

	config.userdata = reinterpret_cast<void*>(new my_sp_userdata(ud));

	// Register the callbacks.
	static sp_session_callbacks callbacks = {
		&handle_logged_in, // logged_in
		&handle_logged_out, // logged_out
		&handle_metadata_updated, // metadata_updated
		&handle_connection_error, // connection_error
		&handle_message_to_user, // message_to_user
		&handle_notify_main_thread, // notify_main_thread
		0, // music_delivery
		&handle_play_token_lost, // play_token_lost
		&handle_log_message, // log_message
		0  // end_of_track
	};

	config.callbacks = &callbacks;

	error = sp_session_init(&config, &session);

	if (error != SP_ERROR_OK) {
		std::ostringstream ss;
		ss << "failed to create session: " << sp_error_message(error);
		throw std::runtime_error(ss.str());
	}

	error = sp_session_login(session, utf8_str(username).c_str(), utf8_str(password).c_str());

	if (error != SP_ERROR_OK) {
		std::ostringstream ss;
		ss << "failed to login: " << sp_error_message(error);
		throw std::runtime_error(ss.str());
	}
}

void SpotifySession::sp_loggedIn() {
	std::cout << __FUNCTION__ << std::endl;
	loggedIn();
}

void SpotifySession::sp_loggedOut() {
	std::cout << __FUNCTION__ << std::endl;
	loggedOut();
}

void SpotifySession::sp_metadataUpdated() {
	std::cout << __FUNCTION__ << std::endl;
	metadataUpdated();
}

void SpotifySession::sp_connectionError(/* error code */) {
	std::cout << __FUNCTION__ << std::endl;
	connectionError();
}

void SpotifySession::sp_messageToUser(QString msg) {
	std::cout << __FUNCTION__ << std::endl;
	std::cout << "SPOTIFY MESSAGE: " << utf8_str(msg) << std::endl;
	messageToUser(msg);
}

void SpotifySession::sp_playTokenLost() {
	std::cout << __FUNCTION__ << std::endl;
	playTokenLost();
}

void SpotifySession::sp_logMessage(QString msg) {
	std::cout << __FUNCTION__ << std::endl;
	std::cout << "SPOTIFY LOG: " << utf8_str(msg) << std::endl;
	logMessage(msg);
}
